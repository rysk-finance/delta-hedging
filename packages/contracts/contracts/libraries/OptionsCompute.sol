// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "prb-math/contracts/PRBMathUD60x18.sol";
import "prb-math/contracts/PRBMathSD59x18.sol";
import "./Types.sol";
import "./CustomErrors.sol";

library OptionsCompute {
    using PRBMathUD60x18 for uint256;
    using PRBMathSD59x18 for int256;

    uint8 private constant SCALE_DECIMALS = 18;

    /// @dev assumes decimals are coming in as e18
    function convertToDecimals(
        uint value,
        uint decimals
    ) 
    internal
    pure 
    returns (uint) 
    {
        if (decimals > SCALE_DECIMALS) { revert(); }
        uint difference = SCALE_DECIMALS - decimals;
        return value / (10**difference);
    }

    function convertFromDecimals(
        uint value,
        uint decimals
    ) 
    internal 
    pure 
    returns (uint) 
    {
        if (decimals > SCALE_DECIMALS) { revert(); }
        uint difference = SCALE_DECIMALS - decimals;
        return value * (10**difference);
    }
    
    // doesnt allow for interest bearing collateral
    function convertToCollateralDenominated(
        uint quote, 
        uint underlyingPrice, 
        Types.OptionSeries memory optionSeries
    ) 
    internal 
    pure 
    returns (uint convertedQuote)
    {
        if(optionSeries.strikeAsset != optionSeries.collateral){
            // convert value from strike asset to collateral asset
            return quote * 1e18 / underlyingPrice;
        } else {
            return quote;
        }
    }

    /** 
     @dev computes the percentage difference between two integers
     @param a the smaller integer
     @param b the larger integer
     @return uint256 the percentage differnce
    */
    function calculatePercentageDifference(
        uint256 a,
        uint256 b
    ) 
    internal
    pure 
    returns (uint256) 
    {
        if (a > b) {
            return b.div(a);
        }
        return a.div(b);
    }
    /**
    * @notice get the latest oracle fed portfolio values and check when they were last updated and make sure this is within a reasonable window
    */
    function validatePortfolioValues(
        uint256 spotPrice, 
        Types.PortfolioValues memory portfolioValues,
        uint256 maxTimeDeviationThreshold,
        uint256 maxPriceDeviationThreshold
        ) 
        public
        view
        {
        uint256 timeDelta = block.timestamp - portfolioValues.timestamp;
        // If too much time has passed we want to prevent a possible oracle attack
        if (timeDelta > maxTimeDeviationThreshold) { revert CustomErrors.TimeDeltaExceedsThreshold(timeDelta); }
        uint256 priceDelta = calculatePercentageDifference(spotPrice, portfolioValues.spotPrice);
        // If price has deviated too much we want to prevent a possible oracle attack
        if (priceDelta > maxPriceDeviationThreshold) { revert CustomErrors.PriceDeltaExceedsThreshold(priceDelta); }
    }
}
