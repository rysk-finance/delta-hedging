import hre, { ethers, network } from "hardhat"
import { BigNumberish, Contract, utils, Signer, BigNumber } from "ethers"
import {
	toWei,
	call,
	put,
	fromWei,
	convertRounded,
	toUSDC,
	fromOpyn,
	scaleNum
} from "../utils/conversion-helper"
import { deploySystem, deployLiquidityPool } from "../utils/generic-system-deployer"
import moment from "moment"
//@ts-ignore
import { expect } from "chai"
import Otoken from "../artifacts/contracts/packages/opyn/core/Otoken.sol/Otoken.json"
import LiquidityPoolSol from "../artifacts/contracts/LiquidityPool.sol/LiquidityPool.json"
import { ERC20Interface } from "../types/ERC20Interface"
import { MintableERC20 } from "../types/MintableERC20"
import { OptionRegistry } from "../types/OptionRegistry"
import { MockPortfolioValuesFeed } from "../types/MockPortfolioValuesFeed"
import { Otoken as IOToken } from "../types/Otoken"
import { PriceFeed } from "../types/PriceFeed"
import { LiquidityPool } from "../types/LiquidityPool"
import { WETH } from "../types/WETH"
import { Protocol } from "../types/Protocol"
import { Volatility } from "../types/Volatility"
import { NewController } from "../types/NewController"
import { AddressBook } from "../types/AddressBook"
import { Oracle } from "../types/Oracle"
import { OptionHandler } from "../types/OptionHandler"
import { NewMarginCalculator } from "../types/NewMarginCalculator"
import {
	setupTestOracle,
	calculateOptionDeltaLocally,
	calculateOptionQuoteLocally
} from "./helpers"
import { MockChainlinkAggregator } from "../types/MockChainlinkAggregator"
import { deployOpyn } from "../utils/opyn-deployer"
import { VolatilityFeed } from "../types/VolatilityFeed"
import { getPortfolioValues } from "../utils/portfolioValues"

let usd: MintableERC20
let wethERC20: ERC20Interface
let weth: WETH
let optionRegistry: OptionRegistry
let optionProtocol: Protocol
let signers: Signer[]
let sender: Signer
let senderAddress: string
let liquidityPool: LiquidityPool
let priceFeed: PriceFeed
let volatility: Volatility
let volFeed: VolatilityFeed
let controller: NewController
let addressBook: AddressBook
let newCalculator: NewMarginCalculator
let oracle: Oracle
let opynAggregator: MockChainlinkAggregator
let portfolioValuesFeed: MockPortfolioValuesFeed
let handler: OptionHandler
let Option: IOToken
let authority: string
let rewindBlock: Number

const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000"

/* --- variables to change --- */

// Date for option to expire on format yyyy-mm-dd
// Will automatically convert to 08:00 UTC timestamp
// First mined block will be timestamped 2022-02-27 19:05 UTC
const expiryDate: string = "2022-04-05"
// decimal representation of a percentage
const rfr: string = "0.03"
// edit depending on the chain id to be tested on
const chainId = 1
const oTokenDecimalShift18 = 10000000000
// amount of dollars OTM written options will be (both puts and calls)
// use negative numbers for ITM options
const strike = "-500"

// balances to deposit into the LP
const liquidityPoolUsdcDeposit = "1000000"

// attacker deposit LP70839675
const attackerUsdcDeposit = "1000"

// balance to withdraw after deposit
const liquidityPoolWethWidthdraw = "0.1"

const minCallStrikePrice = utils.parseEther("500")
const maxCallStrikePrice = utils.parseEther("20000")
const minPutStrikePrice = utils.parseEther("500")
const maxPutStrikePrice = utils.parseEther("20000")
// one week in seconds
const minExpiry = 86400 * 7
// 365 days in seconds
const maxExpiry = 86400 * 365

const productSpotShockValue = scaleNum("0.6", 27)
// array of time to expiry
const day = 60 * 60 * 24
const timeToExpiry = [day * 7, day * 14, day * 28, day * 42, day * 56]
// array of upper bound value correspond to time to expiry
const expiryToValue = [
	scaleNum("0.1678", 27),
	scaleNum("0.237", 27),
	scaleNum("0.3326", 27),
	scaleNum("0.4032", 27),
	scaleNum("0.4603", 27)
]

/* --- end variables to change --- */

const expiration = moment.utc(expiryDate).add(8, "h").valueOf() / 1000

const CALL_FLAVOR = false
const PUT_FLAVOR = true
describe("RR oracle between update attack vector", function () {
	describe("Sc 1. Single large option purchase and update checks", function () {
		before(async function () {
			await hre.network.provider.request({
				method: "hardhat_reset",
				params: [
					{
						forking: {
							chainId: 1,
							jsonRpcUrl: `https://eth-mainnet.alchemyapi.io/v2/${process.env.ALCHEMY}`,
							blockNumber: 14290000
						}
					}
				]
			})
			signers = await ethers.getSigners()
			sender = signers[0]
			let opynParams = await deployOpyn(signers, productSpotShockValue, timeToExpiry, expiryToValue)
			controller = opynParams.controller
			addressBook = opynParams.addressBook
			oracle = opynParams.oracle
			newCalculator = opynParams.newCalculator
			// get the oracle
			const res = await setupTestOracle(await signers[0].getAddress())
			oracle = res[0] as Oracle
			opynAggregator = res[1] as MockChainlinkAggregator
			let deployParams = await deploySystem(signers, oracle, opynAggregator)
			weth = deployParams.weth
			wethERC20 = deployParams.wethERC20
			usd = deployParams.usd
			optionRegistry = deployParams.optionRegistry
			priceFeed = deployParams.priceFeed
			volFeed = deployParams.volFeed
			portfolioValuesFeed = deployParams.portfolioValuesFeed
			optionProtocol = deployParams.optionProtocol
			authority = deployParams.authority.address
			senderAddress = await signers[0].getAddress()
			let lpParams = await deployLiquidityPool(
				signers,
				optionProtocol,
				usd,
				wethERC20,
				rfr,
				minCallStrikePrice,
				minPutStrikePrice,
				maxCallStrikePrice,
				maxPutStrikePrice,
				minExpiry,
				maxExpiry,
				optionRegistry,
				portfolioValuesFeed,
				authority
			)
			volatility = lpParams.volatility
			liquidityPool = lpParams.liquidityPool
			handler = lpParams.handler
			rewindBlock = (await hre.ethers.provider.getBlock("latest")).number
		})
		it("SETUP: set sabrParams", async () => {
			const proposedSabrParams = {
				callAlpha: 250000,
				callBeta: 1_000000,
				callRho: -300000,
				callVolvol: 1_500000,
				putAlpha: 250000,
				putBeta: 1_000000,
				putRho: -300000,
				putVolvol: 1_500000
			}
			await volFeed.setSabrParameters(proposedSabrParams, expiration)
			const volFeedSabrParams = await volFeed.sabrParams(expiration)
			expect(proposedSabrParams.callAlpha).to.equal(volFeedSabrParams.callAlpha)
			expect(proposedSabrParams.callBeta).to.equal(volFeedSabrParams.callBeta)
			expect(proposedSabrParams.callRho).to.equal(volFeedSabrParams.callRho)
			expect(proposedSabrParams.callVolvol).to.equal(volFeedSabrParams.callVolvol)
			expect(proposedSabrParams.putAlpha).to.equal(volFeedSabrParams.putAlpha)
			expect(proposedSabrParams.putBeta).to.equal(volFeedSabrParams.putBeta)
			expect(proposedSabrParams.putRho).to.equal(volFeedSabrParams.putRho)
			expect(proposedSabrParams.putVolvol).to.equal(volFeedSabrParams.putVolvol)
		})
		it("Sc1. Adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(senderAddress, toUSDC(liquidityPoolUsdcDeposit))
			await usdWhaleConnect.transfer(senderAddress, toUSDC("1000000"))
			const balance = await usd.balanceOf(senderAddress)
			await usd.approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(senderAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6))
		})
		it("Sc1. Another adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			const depositor = signers[1]
			const depositorAddress = await depositor.getAddress()
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(depositorAddress, toUSDC(liquidityPoolUsdcDeposit))
			const balance = await usd.balanceOf(depositorAddress)
			await usd.connect(depositor).approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.connect(depositor).deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(depositorAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6).mul(2))
		})
		it("Sc1. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("1"),
				weth.address,
				usd.address,
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
		})
		let localQuote: number
		let localDelta: BigNumber
		let priceQuote: BigNumber
		it("Sc1. LP Writes a WETH/USD put collateralized by USD for premium to the attacker", async () => {
			// registry requires liquidity pool to be owner
			optionRegistry.setLiquidityPool(liquidityPool.address)
			const amount = toWei("350")
			const blockNum = await ethers.provider.getBlockNumber()
			const block = await ethers.provider.getBlock(blockNum)
			const { timestamp } = block

			// opyn contracts require expiration to be at 8:00 UTC
			const collateralAllocatedBefore = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedBefore })

			priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const strikePrice = priceQuote.sub(toWei(strike))
			const lpUSDBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const proposedSeries = {
				expiration: expiration,
				isPut: true,
				strike: BigNumber.from(strikePrice),
				strikeAsset: usd.address,
				underlying: weth.address,
				collateral: usd.address
			}
			localDelta = await calculateOptionDeltaLocally(
				liquidityPool,
				priceFeed,
				proposedSeries,
				amount,
				true
			)
			localQuote = await calculateOptionQuoteLocally(
				liquidityPool,
				optionRegistry,
				usd,
				priceFeed,
				proposedSeries,
				amount,
				false
			)
			const quote = (
				await liquidityPool.quotePriceWithUtilizationGreeks(proposedSeries, amount, false)
			)[0]
			console.log({ quote: fromWei(quote) })
			await usd.approve(handler.address, toWei("100000000000"))
			const seriesAddress = (await handler.callStatic.issueAndWriteOption(proposedSeries, amount))
				.series
			const write = await handler.issueAndWriteOption(proposedSeries, amount)
			const optionToken = new Contract(seriesAddress, Otoken.abi, sender) as IOToken
			const prevNAV = await liquidityPool.getNAV()
			Option = optionToken
			const buyerOptionBalance = await Option.balanceOf(senderAddress)
			console.log("Pool should now have delta value of: " + localDelta)
			console.log("Pool should now have an options portfolio value of (or liabilities): " + localQuote)
			console.log("NAV after issuance should be: " + toWei(liquidityPoolUsdcDeposit).mul(2))
			console.log("NAV after issuance is: " + (await liquidityPool.getNAV()))
			const collateralAllocatedAfter = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedAfter })
			//@ts-ignore
			const totalInterest = await Option.totalSupply()
			const lpUSDBalance = await usd.balanceOf(liquidityPool.address)
			const balanceDiff = lpUSDBalanceBefore.sub(lpUSDBalance)
			expect(fromOpyn(buyerOptionBalance)).to.eq(fromWei(amount))
			expect(fromOpyn(totalInterest)).to.eq(fromWei(amount))
		})
		it("Sc1. should update NAV after fulfill", async () => {
			const beforeNAV = await liquidityPool.getNAV()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			const afterNAV = await liquidityPool.getNAV()
			console.log({ beforeNAV, afterNAV })
			const collateralAllocated = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocated })
		})
		let shares: BigNumber
		it("Sc1. initiates withdraw liquidity", async () => {
			shares = await liquidityPool.callStatic.redeem(toWei("100000000"))
			await liquidityPool.initiateWithdraw(shares)
		})
		it("Sc1. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("3"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
		})
		// now the attacker just withdraws funds
		it("Sc1. attacker withdraws liquidity before delta and portfolio values update", async () => {
			console.log("liabilities are now 0 because the pool isnt updated")
			const usdcBalanceBefore = await usd.balanceOf(senderAddress)
			const lpBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const prevNAV = await liquidityPool.getNAV()
			await liquidityPool.completeWithdraw()
			const lpBalanceAfter = await usd.balanceOf(liquidityPool.address)
			const usdcBalanceAfter = await usd.balanceOf(senderAddress)
			console.log("USDC withdrawn: " + usdcBalanceAfter.sub(usdcBalanceBefore))
			console.log("NAV after withdraw should be: " + toWei(liquidityPoolUsdcDeposit))
			console.log("NAV after withdraw is: " + (await liquidityPool.getNAV()))
			const nextNav = await liquidityPool.getNAV()
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("4"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			console.log("NAV after update should be: " + toWei(liquidityPoolUsdcDeposit))
			console.log("NAV after update is: " + (await liquidityPool.getNAV()))
		})
	})
	describe("Sc 2. Two Seperate Single large option purchase and update checks", function () {
		before(async function () {
			await hre.network.provider.request({
				method: "hardhat_reset",
				params: [
					{
						forking: {
							chainId: 1,
							jsonRpcUrl: `https://eth-mainnet.alchemyapi.io/v2/${process.env.ALCHEMY}`,
							blockNumber: 14290000
						}
					}
				]
			})
			signers = await ethers.getSigners()
			sender = signers[0]
			let opynParams = await deployOpyn(signers, productSpotShockValue, timeToExpiry, expiryToValue)
			controller = opynParams.controller
			addressBook = opynParams.addressBook
			oracle = opynParams.oracle
			newCalculator = opynParams.newCalculator
			// get the oracle
			const res = await setupTestOracle(await signers[0].getAddress())
			oracle = res[0] as Oracle
			opynAggregator = res[1] as MockChainlinkAggregator
			let deployParams = await deploySystem(signers, oracle, opynAggregator)
			weth = deployParams.weth
			wethERC20 = deployParams.wethERC20
			usd = deployParams.usd
			optionRegistry = deployParams.optionRegistry
			priceFeed = deployParams.priceFeed
			volFeed = deployParams.volFeed
			portfolioValuesFeed = deployParams.portfolioValuesFeed
			optionProtocol = deployParams.optionProtocol
			authority = deployParams.authority.address
			senderAddress = await signers[0].getAddress()
			let lpParams = await deployLiquidityPool(
				signers,
				optionProtocol,
				usd,
				wethERC20,
				rfr,
				minCallStrikePrice,
				minPutStrikePrice,
				maxCallStrikePrice,
				maxPutStrikePrice,
				minExpiry,
				maxExpiry,
				optionRegistry,
				portfolioValuesFeed,
				authority
			)
			volatility = lpParams.volatility
			liquidityPool = lpParams.liquidityPool
			handler = lpParams.handler
			rewindBlock = (await hre.ethers.provider.getBlock("latest")).number
		})
		it("SETUP: set sabrParams", async () => {
			const proposedSabrParams = {
				callAlpha: 250000,
				callBeta: 1_000000,
				callRho: -300000,
				callVolvol: 1_500000,
				putAlpha: 250000,
				putBeta: 1_000000,
				putRho: -300000,
				putVolvol: 1_500000
			}
			await volFeed.setSabrParameters(proposedSabrParams, expiration)
			const volFeedSabrParams = await volFeed.sabrParams(expiration)
			expect(proposedSabrParams.callAlpha).to.equal(volFeedSabrParams.callAlpha)
			expect(proposedSabrParams.callBeta).to.equal(volFeedSabrParams.callBeta)
			expect(proposedSabrParams.callRho).to.equal(volFeedSabrParams.callRho)
			expect(proposedSabrParams.callVolvol).to.equal(volFeedSabrParams.callVolvol)
			expect(proposedSabrParams.putAlpha).to.equal(volFeedSabrParams.putAlpha)
			expect(proposedSabrParams.putBeta).to.equal(volFeedSabrParams.putBeta)
			expect(proposedSabrParams.putRho).to.equal(volFeedSabrParams.putRho)
			expect(proposedSabrParams.putVolvol).to.equal(volFeedSabrParams.putVolvol)
		})
		it("Sc2. Adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(senderAddress, toUSDC(liquidityPoolUsdcDeposit))
			await usdWhaleConnect.transfer(senderAddress, toUSDC("1000000"))
			const balance = await usd.balanceOf(senderAddress)
			await usd.approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(senderAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6))
		})
		it("Sc2. Another adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			const depositor = signers[1]
			const depositorAddress = await depositor.getAddress()
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(depositorAddress, toUSDC(liquidityPoolUsdcDeposit))
			const balance = await usd.balanceOf(depositorAddress)
			await usd.connect(depositor).approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.connect(depositor).deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(depositorAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6).mul(2))
		})
		it("Sc2. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
		})
		let localQuotes = 0
		let localDeltas = BigNumber.from(0)
		let priceQuote: BigNumber
		it("Sc2. LP Writes a WETH/USD put collateralized by USD for premium to the attacker", async () => {
			// registry requires liquidity pool to be owner
			optionRegistry.setLiquidityPool(liquidityPool.address)
			const amount = toWei("400")
			const blockNum = await ethers.provider.getBlockNumber()
			const block = await ethers.provider.getBlock(blockNum)
			const { timestamp } = block

			// opyn contracts require expiration to be at 8:00 UTC
			const collateralAllocatedBefore = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedBefore })

			priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const strikePrice = priceQuote.sub(toWei(strike))
			const lpUSDBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const proposedSeries = {
				expiration: expiration,
				isPut: true,
				strike: BigNumber.from(strikePrice),
				strikeAsset: usd.address,
				underlying: weth.address,
				collateral: usd.address
			}
			localDeltas = localDeltas.add(
				await calculateOptionDeltaLocally(liquidityPool, priceFeed, proposedSeries, amount, true)
			)
			localQuotes =
				localQuotes +
				(await calculateOptionQuoteLocally(
					liquidityPool,
					optionRegistry,
					usd,
					priceFeed,
					proposedSeries,
					amount,
					false
				))
			const quote = (
				await liquidityPool.quotePriceWithUtilizationGreeks(proposedSeries, amount, false)
			)[0]
			console.log({ quote: fromWei(quote) })
			await usd.approve(handler.address, toWei("100000000000"))
			const seriesAddress = (await handler.callStatic.issueAndWriteOption(proposedSeries, amount))
				.series
			const write = await handler.issueAndWriteOption(proposedSeries, amount)
			const optionToken = new Contract(seriesAddress, Otoken.abi, sender) as IOToken
			const prevNAV = await liquidityPool.getNAV()
			Option = optionToken
			const buyerOptionBalance = await Option.balanceOf(senderAddress)
			console.log("Pool should now have delta value of: " + localDeltas)
			console.log(
				"Pool should now have an options portfolio value of (or liabilities): " + localQuotes
			)
			console.log("NAV after issuance should be: " + toWei(liquidityPoolUsdcDeposit).mul(2))
			console.log("NAV after issuance is: " + (await liquidityPool.getNAV()))
			const collateralAllocatedAfter = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedAfter })
			//@ts-ignore
			const totalInterest = await Option.totalSupply()
			const lpUSDBalance = await usd.balanceOf(liquidityPool.address)
			const balanceDiff = lpUSDBalanceBefore.sub(lpUSDBalance)
			expect(fromOpyn(buyerOptionBalance)).to.eq(fromWei(amount))
			expect(fromOpyn(totalInterest)).to.eq(fromWei(amount))
		})
		it("Sc2. LP Writes a WETH/USD call collateralized by USD for premium to the attacker", async () => {
			// registry requires liquidity pool to be owner
			optionRegistry.setLiquidityPool(liquidityPool.address)
			const amount = toWei("100")
			const blockNum = await ethers.provider.getBlockNumber()
			const block = await ethers.provider.getBlock(blockNum)
			const { timestamp } = block

			// opyn contracts require expiration to be at 8:00 UTC
			const collateralAllocatedBefore = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedBefore })

			priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const strikePrice = priceQuote.add(toWei(strike))
			const lpUSDBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const proposedSeries = {
				expiration: expiration,
				isPut: false,
				strike: BigNumber.from(strikePrice),
				strikeAsset: usd.address,
				underlying: weth.address,
				collateral: usd.address
			}
			localDeltas = localDeltas.add(
				await calculateOptionDeltaLocally(liquidityPool, priceFeed, proposedSeries, amount, false)
			)
			localQuotes =
				localQuotes +
				(await calculateOptionQuoteLocally(
					liquidityPool,
					optionRegistry,
					usd,
					priceFeed,
					proposedSeries,
					amount,
					false
				))
			const quote = (
				await liquidityPool.quotePriceWithUtilizationGreeks(proposedSeries, amount, false)
			)[0]
			console.log({ quote: fromWei(quote) })
			await usd.approve(handler.address, toWei("100000000000"))
			const seriesAddress = (await handler.callStatic.issueAndWriteOption(proposedSeries, amount))
				.series
			const write = await handler.issueAndWriteOption(proposedSeries, amount)
			const optionToken = new Contract(seriesAddress, Otoken.abi, sender) as IOToken
			const prevNAV = await liquidityPool.getNAV()
			Option = optionToken
			const buyerOptionBalance = await Option.balanceOf(senderAddress)
			console.log("Pool should now have delta value of: " + localDeltas)
			console.log(
				"Pool should now have an options portfolio value of (or liabilities): " + localQuotes
			)
			console.log("NAV after issuance should be: " + toWei(liquidityPoolUsdcDeposit).mul(2))
			console.log("NAV after issuance is: " + (await liquidityPool.getNAV()))
			const collateralAllocatedAfter = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedAfter })
			//@ts-ignore
			const totalInterest = await Option.totalSupply()
			const lpUSDBalance = await usd.balanceOf(liquidityPool.address)
			const balanceDiff = lpUSDBalanceBefore.sub(lpUSDBalance)
			expect(fromOpyn(buyerOptionBalance)).to.eq(fromWei(amount))
			expect(fromOpyn(totalInterest)).to.eq(fromWei(amount))
		})
		it("Sc2. should update NAV after fulfill", async () => {
			const beforeNAV = await liquidityPool.getNAV()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			const afterNAV = await liquidityPool.getNAV()
			console.log({ beforeNAV, afterNAV })
			const collateralAllocated = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocated })
		})
		let shares: BigNumber
		it("Sc2. initiates withdraw liquidity", async () => {
			shares = await liquidityPool.callStatic.redeem(toWei("100000000"))
			await liquidityPool.initiateWithdraw(shares)
		})
		it("Sc2. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
			console.log("NAV after withdraw is: " + (await liquidityPool.getNAV()))
		})
	})
	describe("Sc 3. Single large option purchase and update and another option purchase checks", function () {
		before(async function () {
			await hre.network.provider.request({
				method: "hardhat_reset",
				params: [
					{
						forking: {
							chainId: 1,
							jsonRpcUrl: `https://eth-mainnet.alchemyapi.io/v2/${process.env.ALCHEMY}`,
							blockNumber: 14290000
						}
					}
				]
			})
			signers = await ethers.getSigners()
			sender = signers[0]
			let opynParams = await deployOpyn(signers, productSpotShockValue, timeToExpiry, expiryToValue)
			controller = opynParams.controller
			addressBook = opynParams.addressBook
			oracle = opynParams.oracle
			newCalculator = opynParams.newCalculator
			// get the oracle
			const res = await setupTestOracle(await signers[0].getAddress())
			oracle = res[0] as Oracle
			opynAggregator = res[1] as MockChainlinkAggregator
			let deployParams = await deploySystem(signers, oracle, opynAggregator)
			weth = deployParams.weth
			wethERC20 = deployParams.wethERC20
			usd = deployParams.usd
			optionRegistry = deployParams.optionRegistry
			priceFeed = deployParams.priceFeed
			volFeed = deployParams.volFeed
			portfolioValuesFeed = deployParams.portfolioValuesFeed
			optionProtocol = deployParams.optionProtocol
			authority = deployParams.authority.address
			senderAddress = await signers[0].getAddress()
			let lpParams = await deployLiquidityPool(
				signers,
				optionProtocol,
				usd,
				wethERC20,
				rfr,
				minCallStrikePrice,
				minPutStrikePrice,
				maxCallStrikePrice,
				maxPutStrikePrice,
				minExpiry,
				maxExpiry,
				optionRegistry,
				portfolioValuesFeed,
				authority
			)
			volatility = lpParams.volatility
			liquidityPool = lpParams.liquidityPool
			handler = lpParams.handler
			rewindBlock = (await hre.ethers.provider.getBlock("latest")).number
		})
		it("SETUP: set sabrParams", async () => {
			const proposedSabrParams = {
				callAlpha: 250000,
				callBeta: 1_000000,
				callRho: -300000,
				callVolvol: 1_500000,
				putAlpha: 250000,
				putBeta: 1_000000,
				putRho: -300000,
				putVolvol: 1_500000
			}
			await volFeed.setSabrParameters(proposedSabrParams, expiration)
			const volFeedSabrParams = await volFeed.sabrParams(expiration)
			expect(proposedSabrParams.callAlpha).to.equal(volFeedSabrParams.callAlpha)
			expect(proposedSabrParams.callBeta).to.equal(volFeedSabrParams.callBeta)
			expect(proposedSabrParams.callRho).to.equal(volFeedSabrParams.callRho)
			expect(proposedSabrParams.callVolvol).to.equal(volFeedSabrParams.callVolvol)
			expect(proposedSabrParams.putAlpha).to.equal(volFeedSabrParams.putAlpha)
			expect(proposedSabrParams.putBeta).to.equal(volFeedSabrParams.putBeta)
			expect(proposedSabrParams.putRho).to.equal(volFeedSabrParams.putRho)
			expect(proposedSabrParams.putVolvol).to.equal(volFeedSabrParams.putVolvol)
		})
		it("Sc3. Adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(senderAddress, toUSDC(liquidityPoolUsdcDeposit))
			await usdWhaleConnect.transfer(senderAddress, toUSDC("1000000"))
			const balance = await usd.balanceOf(senderAddress)
			await usd.approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(senderAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6))
		})
		it("Sc3. Another adds liquidity to the liquidityPool", async () => {
			const USDC_WHALE = "0x55fe002aeff02f77364de339a1292923a15844b8"
			const depositor = signers[1]
			const depositorAddress = await depositor.getAddress()
			await hre.network.provider.request({
				method: "hardhat_impersonateAccount",
				params: [USDC_WHALE]
			})
			const usdcWhale = await ethers.getSigner(USDC_WHALE)
			const usdWhaleConnect = await usd.connect(usdcWhale)
			await usdWhaleConnect.transfer(depositorAddress, toUSDC(liquidityPoolUsdcDeposit))
			const balance = await usd.balanceOf(depositorAddress)
			await usd.connect(depositor).approve(liquidityPool.address, toWei(liquidityPoolUsdcDeposit))
			const deposit = await liquidityPool.connect(depositor).deposit(toUSDC(liquidityPoolUsdcDeposit))
			const liquidityPoolBalanceUSDC = await usd.balanceOf(liquidityPool.address)
			const receipt = await deposit.wait(1)
			const event = receipt?.events?.find(x => x.event == "Deposit")
			const newBalance = await usd.balanceOf(depositorAddress)
			expect(event?.event).to.eq("Deposit")
			expect(balance.sub(newBalance)).to.eq(toUSDC(liquidityPoolUsdcDeposit))
			expect(liquidityPoolBalanceUSDC).to.equal(utils.parseUnits(liquidityPoolUsdcDeposit, 6).mul(2))
		})
		it("Sc3. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
		})
		let localQuotes = 0
		let localDeltas = BigNumber.from(0)
		let priceQuote: BigNumber
		it("Sc3. LP Writes a WETH/USD put collateralized by USD for premium to the attacker", async () => {
			// registry requires liquidity pool to be owner
			optionRegistry.setLiquidityPool(liquidityPool.address)
			const amount = toWei("400")
			const blockNum = await ethers.provider.getBlockNumber()
			const block = await ethers.provider.getBlock(blockNum)
			const { timestamp } = block

			// opyn contracts require expiration to be at 8:00 UTC
			const collateralAllocatedBefore = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedBefore })

			priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const strikePrice = priceQuote.sub(toWei(strike))
			const lpUSDBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const proposedSeries = {
				expiration: expiration,
				isPut: true,
				strike: BigNumber.from(strikePrice),
				strikeAsset: usd.address,
				underlying: weth.address,
				collateral: usd.address
			}
			localDeltas = localDeltas.add(
				await calculateOptionDeltaLocally(liquidityPool, priceFeed, proposedSeries, amount, true)
			)
			localQuotes =
				localQuotes +
				(await calculateOptionQuoteLocally(
					liquidityPool,
					optionRegistry,
					usd,
					priceFeed,
					proposedSeries,
					amount,
					false
				))
			const quote = (
				await liquidityPool.quotePriceWithUtilizationGreeks(proposedSeries, amount, false)
			)[0]
			console.log({ quote: fromWei(quote) })
			await usd.approve(handler.address, toWei("100000000000"))
			const seriesAddress = (await handler.callStatic.issueAndWriteOption(proposedSeries, amount))
				.series
			const write = await handler.issueAndWriteOption(proposedSeries, amount)
			const optionToken = new Contract(seriesAddress, Otoken.abi, sender) as IOToken
			const prevNAV = await liquidityPool.getNAV()
			Option = optionToken
			const buyerOptionBalance = await Option.balanceOf(senderAddress)
			console.log("Pool should now have delta value of: " + localDeltas)
			console.log(
				"Pool should now have an options portfolio value of (or liabilities): " + localQuotes
			)
			console.log("NAV after issuance should be: " + toWei(liquidityPoolUsdcDeposit).mul(2))
			console.log("NAV after issuance is: " + (await liquidityPool.getNAV()))
			const collateralAllocatedAfter = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedAfter })
			//@ts-ignore
			const totalInterest = await Option.totalSupply()
			const lpUSDBalance = await usd.balanceOf(liquidityPool.address)
			const balanceDiff = lpUSDBalanceBefore.sub(lpUSDBalance)
			expect(fromOpyn(buyerOptionBalance)).to.eq(fromWei(amount))
			expect(fromOpyn(totalInterest)).to.eq(fromWei(amount))
		})
		it("Sc3. should update NAV after fulfill", async () => {
			const beforeNAV = await liquidityPool.getNAV()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			const afterNAV = await liquidityPool.getNAV()
			console.log({ beforeNAV, afterNAV })
			const collateralAllocated = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocated })
		})
		it("Sc3. LP Writes a WETH/USD call collateralized by USD for premium to the attacker", async () => {
			// registry requires liquidity pool to be owner
			optionRegistry.setLiquidityPool(liquidityPool.address)
			const amount = toWei("100")
			const blockNum = await ethers.provider.getBlockNumber()
			const block = await ethers.provider.getBlock(blockNum)
			const { timestamp } = block

			// opyn contracts require expiration to be at 8:00 UTC
			const collateralAllocatedBefore = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedBefore })

			priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const strikePrice = priceQuote.add(toWei(strike))
			const lpUSDBalanceBefore = await usd.balanceOf(liquidityPool.address)
			const proposedSeries = {
				expiration: expiration,
				isPut: false,
				strike: BigNumber.from(strikePrice),
				strikeAsset: usd.address,
				underlying: weth.address,
				collateral: usd.address
			}
			localDeltas = localDeltas.add(
				await calculateOptionDeltaLocally(liquidityPool, priceFeed, proposedSeries, amount, false)
			)
			localQuotes =
				localQuotes +
				(await calculateOptionQuoteLocally(
					liquidityPool,
					optionRegistry,
					usd,
					priceFeed,
					proposedSeries,
					amount,
					false
				))
			const quote = (
				await liquidityPool.quotePriceWithUtilizationGreeks(proposedSeries, amount, false)
			)[0]
			console.log({ quote: fromWei(quote) })
			await usd.approve(handler.address, toWei("100000000000"))
			const seriesAddress = (await handler.callStatic.issueAndWriteOption(proposedSeries, amount))
				.series
			const write = await handler.issueAndWriteOption(proposedSeries, amount)
			const optionToken = new Contract(seriesAddress, Otoken.abi, sender) as IOToken
			const prevNAV = await liquidityPool.getNAV()
			Option = optionToken
			const buyerOptionBalance = await Option.balanceOf(senderAddress)
			console.log("Pool should now have delta value of: " + localDeltas)
			console.log(
				"Pool should now have an options portfolio value of (or liabilities): " + localQuotes
			)
			console.log("NAV after issuance should be: " + toWei(liquidityPoolUsdcDeposit).mul(2))
			console.log("NAV after issuance is: " + (await liquidityPool.getNAV()))
			const collateralAllocatedAfter = await liquidityPool.collateralAllocated()
			console.log({ collateralAllocatedAfter })
			//@ts-ignore
			const totalInterest = await Option.totalSupply()
			const lpUSDBalance = await usd.balanceOf(liquidityPool.address)
			const balanceDiff = lpUSDBalanceBefore.sub(lpUSDBalance)
			expect(fromOpyn(buyerOptionBalance)).to.eq(fromWei(amount))
			expect(fromOpyn(totalInterest)).to.eq(fromWei(amount))
		})
		let shares: BigNumber
		it("Sc3. initiates withdraw liquidity", async () => {
			shares = await liquidityPool.callStatic.redeem(toWei("100000000"))
			await liquidityPool.initiateWithdraw(shares)
		})
		it("Sc2. pauses trading and executes epoch", async () => {
			await liquidityPool.pauseTradingAndRequest()
			const priceQuote = await priceFeed.getNormalizedRate(weth.address, usd.address)
			const {
				portfolioDelta,
				portfolioGamma,
				portfolioTheta,
				portfolioVega,
				callsPutsValue,
				bsCallsPutsValue
			} = await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			console.log(
				await getPortfolioValues(liquidityPool, controller, optionRegistry, priceFeed, oracle)
			)
			await portfolioValuesFeed.fulfill(
				utils.formatBytes32String("2"),
				weth.address,
				usd.address,
				BigNumber.from(toWei(portfolioDelta.toString())),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(0),
				BigNumber.from(toWei(callsPutsValue.toString())),
				BigNumber.from(priceQuote)
			)
			await liquidityPool.executeEpochCalculation()
			console.log("NAV after withdraw is: " + (await liquidityPool.getNAV()))
		})
	})
})
